# 1.3 å®šä¹‰æ–°çš„å‡½æ•°

æˆ‘ä»¬å·²ç»åœ¨ Python ä¸­ç¡®å®šäº†å¼ºå¤§çš„ç¼–ç¨‹è¯­è¨€ä¸­ä¸€äº›å¿…é¡»å‡ºç°çš„è¦ç´ ï¼š

1. ==åŸºæœ¬(primitive)==çš„å†…ç½®æ•°æ®å’Œå‡½æ•°ï¼šæ•°å­—å’Œç®—æœ¯è¿ç®—ã€‚
2. ==ç»„åˆ(combining)==æ–¹å¼ï¼šåµŒå¥—å‡½æ•°ã€‚
3. å—é™çš„==æŠ½è±¡(abstraction)==æ–¹å¼ï¼šå°†åç§°ä¸å€¼ç»‘å®šã€‚

ç°åœ¨æˆ‘ä»¬æ¥å­¦ä¹ ==å‡½æ•°å®šä¹‰==ï¼Œè¿™æ˜¯ä¸€ç§æ›´ä¸ºå¼ºå¤§çš„æŠ½è±¡æŠ€æœ¯ï¼Œé€šè¿‡å®ƒå¯ä»¥å°†åç§°ä¸å¤åˆæ“ä½œç»‘å®šä¸ºä¸€ä¸ªå•å…ƒã€‚

é¦–å…ˆæ¥ç ”ç©¶ä¸€ä¸‹==å¹³æ–¹==çš„æ¦‚å¿µã€‚æˆ‘ä»¬å¯èƒ½ä¼šè¯´ï¼šâ€œä¸€ä¸ªæ•°ä¹˜ä»¥å®ƒæœ¬èº«å°±æ˜¯å¹³æ–¹ã€‚â€ è¿™åœ¨ Python ä¸­å¯ä»¥è¡¨ç¤ºä¸º

```py
>>> def square(x):
Â Â Â      return mul(x, x)
```

ä¸Šé¢çš„ä»£ç å®šä¹‰äº†ä¸€ä¸ªåä¸ºÂ `square`Â çš„æ–°å‡½æ•°ï¼Œè¿™ä¸ªç”¨æˆ·å®šä¹‰çš„å‡½æ•°å¹¶ä¸ä¼šå†…ç½®åˆ°è§£é‡Šå™¨ä¸­ï¼Œå®ƒè¡¨ç¤ºå°†æŸå€¼ä¸è‡ªèº«ç›¸ä¹˜çš„å¤åˆè¿ç®—ã€‚è¿™ä¸ªå®šä¹‰å°†Â `x`Â ä½œä¸ºè¢«ä¹˜çš„ä¸œè¥¿çš„åç§°ï¼Œç§°ä¸º==å½¢å‚ï¼ˆå½¢å¼å‚æ•°ï¼‰==ï¼ŒåŒæ—¶ä¹Ÿå°†æ­¤å‡½æ•°ä¸åç§°Â `square`Â ç»‘å®šã€‚

==å¦‚ä½•å®šä¹‰å‡½æ•°==ï¼šå‡½æ•°å®šä¹‰åŒ…å«Â `def` è¯­å¥ã€Â `<name å‡½æ•°å>`Â å’Œä¸€ä¸ªä»¥é€—å·åˆ†éš”çš„Â `<formal parameters å½¢å‚>`Â åˆ—è¡¨ï¼Œç„¶åæ˜¯ä¸€ä¸ªè¢«ç§°ä¸ºå‡½æ•°ä½“çš„Â `return` è¯­å¥ï¼Œå®ƒæŒ‡å®šäº†è°ƒç”¨å‡½æ•°æ—¶è¦è®¡ç®—çš„è¡¨è¾¾å¼ï¼Œä¹Ÿå°±æ˜¯å‡½æ•°çš„Â `<return expression è¿”å›è¡¨è¾¾å¼>`Â ï¼š

```py
def <name>(<formal parameters>):
    return <return expression>
```

å‡½æ•°çš„ç¬¬äºŒè¡Œ==å¿…é¡»==è¿›è¡Œç¼©è¿› â€”â€” å¤§å¤šæ•°ç¨‹åºå‘˜ä½¿ç”¨å››ä¸ªç©ºæ ¼ã€‚è¿”å›è¡¨è¾¾å¼ä¼šä½œä¸ºæ–°å®šä¹‰çš„å‡½æ•°çš„ä¸€éƒ¨åˆ†å­˜å‚¨ï¼Œå¹¶ä¸”ä»…åœ¨æœ€ç»ˆè°ƒç”¨è¯¥å‡½æ•°æ—¶æ‰è¿›è¡Œæ±‚å€¼ã€‚

å®šä¹‰äº†Â `square`Â ä¹‹åï¼Œæˆ‘ä»¬å¯ä»¥è°ƒç”¨å®ƒï¼š

```py
>>> square(21)
441
>>> square(add(2, 5))
49
>>> square(square(3))
81
```

æˆ‘ä»¬è¿˜å¯ä»¥å°†Â `square`Â ä½œä¸ºä¸€ä¸ªæ„å»ºå•å…ƒæ¥å®šä¹‰å…¶ä»–å‡½æ•°ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°å®šä¹‰ä¸€ä¸ªå‡½æ•°Â `sum_squares`Â ï¼Œç»™å®šä»»æ„ä¸¤ä¸ªæ•°å­—ä½œä¸ºå‚æ•°ï¼Œè¿”å›å®ƒä»¬çš„å¹³æ–¹å’Œï¼š

```py
>>> def sum_squares(x, y):
Â Â Â      return add(square(x), square(y))

>>> sum_squares(3, 4)
25
```

ç”¨æˆ·å®šä¹‰å‡½æ•°çš„ä½¿ç”¨æ–¹å¼ä¸å†…ç½®å‡½æ•°å®Œå…¨ç›¸åŒã€‚å®é™…ä¸Šï¼Œä»Â `sum_squares`Â çš„å®šä¹‰ä¸­æˆ‘ä»¬å¹¶ä¸èƒ½åˆ¤æ–­Â `square`Â æ˜¯å†…ç½®äºè§£é‡Šå™¨ä¸­ï¼Œè¿˜æ˜¯ä»æ¨¡å—ä¸­å¯¼å…¥çš„ï¼Œåˆæˆ–æ˜¯ç”¨æˆ·å®šä¹‰çš„ã€‚

`def`Â è¯­å¥å’Œèµ‹å€¼è¯­å¥éƒ½å°†åç§°ä¸å€¼ç»‘å®šï¼Œå¹¶ä¸”ç»‘å®šåä»»ä½•ä¹‹å‰çš„ç»‘å®šéƒ½å°†ä¸¢å¤±ã€‚ä¾‹å¦‚ï¼Œä¸‹é¢çš„Â `g`Â é¦–å…ˆæŒ‡çš„æ˜¯ä¸€ä¸ªæ²¡æœ‰å‚æ•°çš„å‡½æ•°ï¼Œç„¶åæ˜¯æŒ‡ä¸€ä¸ªæ•°å­—ï¼Œæœ€åæ˜¯ä¸€ä¸ªå«æœ‰ä¸¤ä¸ªå‚æ•°çš„å‡½æ•°ã€‚

```py
>>> def g():
Â Â Â      return 1
>>> g()
1
>>> g = 2
>>> g
2
>>> def g(h, i):
Â Â Â      return h + i
>>> g(1, 2)
3
```

## 1.3.1 ç¯å¢ƒ

è™½ç„¶æˆ‘ä»¬ç°åœ¨çš„ Python å­é›†å·²ç»è¶³å¤Ÿå¤æ‚ï¼Œä½†ç¨‹åºçš„å«ä¹‰å¹¶ä¸æ˜æ˜¾ã€‚å¦‚æœå½¢å‚ä¸å†…ç½®å‡½æ•°åŒåæ€ä¹ˆåŠï¼Ÿä¸¤ä¸ªå‡½æ•°å¯ä»¥å…±äº«åç§°è€Œä¸ä¼šæ··æ·†å—ï¼Ÿè¦è§£å†³è¿™äº›é—®é¢˜ï¼Œæˆ‘ä»¬å¿…é¡»æ›´è¯¦ç»†åœ°æè¿°ç¯å¢ƒã€‚

æ±‚è§£è¡¨è¾¾å¼çš„ç¯å¢ƒç”±==å¸§(frame)==çš„åºåˆ—ç»„æˆï¼Œå®ƒä»¬å¯ä»¥è¢«æè¿°ä¸ºä¸€äº›ç›’å­ã€‚æ¯ä¸ªå¸§éƒ½åŒ…å«äº†ä¸€äº›ç»‘å®šï¼Œå®ƒä»¬å°†åç§°ä¸å¯¹åº”çš„å€¼ç›¸å…³è”ã€‚==å…¨å±€å¸§(global frame)==åªæœ‰ä¸€ä¸ªã€‚èµ‹å€¼å’Œå¯¼å…¥è¯­å¥ä¼šå°†æ¡ç›®æ·»åŠ åˆ°å½“å‰ç¯å¢ƒçš„ç¬¬ä¸€å¸§ã€‚ç›®å‰ï¼Œæˆ‘ä»¬çš„ç¯å¢ƒä»…ç”±å…¨å±€å¸§ç»„æˆï¼Œ[ç‚¹å‡»è¿™é‡ŒæŸ¥çœ‹å¯¹åº”çš„ç¯å¢ƒå›¾](http://composingprograms.com/tutor.html#code=from+math+import+pi%0Atau+%3D+2+*+pi)ã€‚

![pt_1](/sicp-python/pt_1.png)

> è¯‘è€…æ³¨ï¼šæœ¬ç¿»è¯‘ä¸­çš„ç¯å¢ƒå›¾ä»…ä¸ºåŸæ–‡çš„æˆªå›¾ï¼Œå¹¶ä¸æ˜¯äº¤äº’å¼çš„ï¼Œä½†ä½ å¯ä»¥ç‚¹å‡»å¯¹åº”çš„ Python Tutor é“¾æ¥è¿›è¡ŒæŸ¥çœ‹ ğŸ˜Š

æ­¤==ç¯å¢ƒå›¾(environment diagram)==æ˜¾ç¤ºäº†å½“å‰ç¯å¢ƒä¸­çš„ç»‘å®šï¼Œè¿˜æœ‰åç§°å’Œå€¼çš„ç»‘å®šã€‚~~æœ¬æ–‡ä¸­çš„ç¯å¢ƒå›¾æ˜¯äº¤äº’å¼çš„ï¼šä½ å¯ä»¥é€æ­¥è¿è¡Œå·¦ä¾§ç¨‹åºçš„æ¯ä¸€è¡Œï¼Œç„¶ååœ¨å³ä¾§æŸ¥çœ‹ç¯å¢ƒçŠ¶æ€çš„æ¼”å˜ã€‚~~ä½ è¿˜å¯ä»¥å•å‡» â€œEdit code in Online Python Tutorâ€ ä»¥å°†ç¤ºä¾‹åŠ è½½åˆ° [Online Python Tutor](http://composingprograms.com/tutor.html) ä¸­ã€‚Python Tutor æ˜¯ç”¨äºç”Ÿæˆæ–‡ä¸­ç¯å¢ƒå›¾çš„å·¥å…·ï¼Œç”± [Philip Guo](http://www.pgbovine.net/)Â åˆ›å»ºã€‚æˆ‘ä»¬é¼“åŠ±æ‚¨è‡ªå·±å»åˆ›å»ºç¤ºä¾‹ï¼Œç ”ç©¶å¯¹åº”ç”Ÿæˆçš„ç¯å¢ƒå›¾ã€‚

å‡½æ•°ä¹Ÿä¼šå‡ºç°åœ¨ç¯å¢ƒå›¾ä¸­ã€‚`import` è¯­å¥å°†åç§°ä¸å†…ç½®å‡½æ•°ç»‘å®šã€‚`def` è¯­å¥å°†åç§°ä¸ç”¨æˆ·è‡ªå·±å®šä¹‰çš„å‡½æ•°ç»‘å®šã€‚å¯¼å…¥ `mul` å¹¶å®šä¹‰ `square` åçš„ç»“æœç¯å¢ƒå¦‚ä¸‹æ‰€ç¤ºï¼Œ[ç‚¹å‡»è¿™é‡ŒæŸ¥çœ‹å¯¹åº”çš„ç¯å¢ƒå›¾](http://composingprograms.com/tutor.html#code=from+operator+import+mul%0Adef+square(x)%3A%0A++++return+mul(x,+x))ï¼š

![pt_2](/sicp-python/pt_2.png)

æ¯ä¸ªå‡½æ•°éƒ½æ˜¯ä¸€è¡Œï¼Œä»¥ `func` å¼€å¤´ï¼Œåé¢æ˜¯å‡½æ•°åç§°å’Œå½¢å¼å‚æ•°ã€‚`mul` ç­‰å†…ç½®å‡½æ•°æ²¡æœ‰æ­£å¼çš„å‚æ•°åç§°ï¼Œæ‰€ä»¥éƒ½æ˜¯ä½¿ç”¨ `...` ä»£æ›¿ã€‚

å‡½æ•°åç§°é‡å¤ä¸¤æ¬¡ï¼Œä¸€æ¬¡åœ¨ç¯å¢ƒå¸§ä¸­ï¼Œå¦ä¸€æ¬¡æ˜¯ä½œä¸ºå‡½æ•°çš„ä¸€éƒ¨åˆ†ã€‚å‡½æ•°ä¸­å‡ºç°çš„åç§°å«åš==å†…åœ¨åç§°(intrinsic name)==ã€‚å¸§ä¸­çš„åç§°æ˜¯==ç»‘å®šåç§°(bound name)==ã€‚ä¸¤è€…ä¹‹é—´æœ‰ä¸€ä¸ªåŒºåˆ«ï¼šä¸åŒçš„åç§°å¯èƒ½æŒ‡çš„æ˜¯åŒä¸€ä¸ªå‡½æ•°ï¼Œä½†è¯¥å‡½æ•°æœ¬èº«åªæœ‰ä¸€ä¸ªå†…åœ¨åç§°ã€‚

The name bound to a function in a frame is the one used during evaluation. The intrinsic name of a function does not play a role in evaluation. Step through the example below using theÂ _Forward_Â button to see that once the nameÂ maxÂ is bound to the value 3, it can no longer be used as a function.

![pt_3](/sicp-python/pt_3.png)


The error messageÂ TypeError: 'int' object is not callableÂ is reporting that the nameÂ maxÂ (currently bound to the number 3) is an integer and not a function. Therefore, it cannot be used as the operator in a call expression.

**Function Signatures.**Â Functions differ in the number of arguments that they are allowed to take. To track these requirements, we draw each function in a way that shows the function name and its formal parameters. The user-defined functionÂ squareÂ takes onlyÂ x; providing more or fewer arguments will result in an error. A description of the formal parameters of a function is called the function's signature.

The functionÂ maxÂ can take an arbitrary number of arguments. It is rendered asÂ `max(...)`. Regardless of the number of arguments taken, all built-in functions will be rendered asÂ `<name>(...)`, because these primitive functions were never explicitly defined.

## 1.3.2 è°ƒç”¨ç”¨æˆ·å®šä¹‰çš„å‡½æ•°

To evaluate a call expression whose operator names a user-defined function, the Python interpreter follows a computational process. As with any call expression, the interpreter evaluates the operator and operand expressions, and then applies the named function to the resulting arguments.

Applying a user-defined function introduces a secondÂ _local_Â frame, which is only accessible to that function. To apply a user-defined function to some arguments:

1.  Bind the arguments to the names of the function's formal parameters in a newÂ _local_Â frame.
2.  Execute the body of the function in the environment that starts with this frame.

The environment in which the body is evaluated consists of two frames: first the local frame that contains formal parameter bindings, then the global frame that contains everything else. Each instance of a function application has its own independent local frame.

To illustrate an example in detail, several steps of the environment diagram for the same example are depicted below. After executing the first import statement, only the nameÂ mulÂ is bound in the global frame.

![pt_4](/sicp-python/pt_4.png)


First, the definition statement for the functionÂ squareÂ is executed. Notice that the entireÂ defÂ statement is processed in a single step. The body of a function is not executed until the function is called (not when it is defined).

![pt_5](/sicp-python/pt_5.png)

Next, The square function is called with the argument -2, and so a new frame is created with the formal parameter x bound to the value -2.

![pt_6](/sicp-python/pt_6.png)

Then, the name x is looked up in the current environment, which consists of the two frames shown. In both occurrences, x evaluates to -2, and so the square function returns 4.

![pt_7](/sicp-python/pt_7.png)

The "Return value" in theÂ square()Â frame is not a name binding; instead it indicates the value returned by the function call that created the frame.

Even in this simple example, two different environments are used. The top-level expressionÂ square(-2)Â is evaluated in the global environment, while the return expressionÂ mul(x, x)Â is evaluated in the environment created for by callingÂ square. BothÂ xÂ andÂ mulÂ are bound in this environment, but in different frames.

The order of frames in an environment affects the value returned by looking up a name in an expression. We stated previously that a name is evaluated to the value associated with that name in the current environment. We can now be more precise:

**Name Evaluation.**Â A name evaluates to the value bound to that name in the earliest frame of the current environment in which that name is found.

Our conceptual framework of environments, names, and functions constitutes aÂ _model of evaluation_; while some mechanical details are still unspecified (e.g., how a binding is implemented), our model does precisely and correctly describe how the interpreter evaluates call expressions. In Chapter 3 we will see how this model can serve as a blueprint for implementing a working interpreter for a programming language.

## 1.3.3 ç¤ºä¾‹ï¼šè°ƒç”¨ç”¨æˆ·å®šä¹‰çš„å‡½æ•°

Let us again consider our two simple function definitions and illustrate the process that evaluates a call expression for a user-defined function.

![pt_8](/sicp-python/pt_8.png)

Python first evaluates the name `sum_squares`, which is bound to a user-defined function in the global frame. The primitive numeric expressions 5 and 12 evaluate to the numbers they represent.

Next, Python applies `sum_squares`, which introduces a local frame that binds x to 5 and y to 12.

![pt_9](/sicp-python/pt_9.png)

The body of sum_squares contains this call expression:

```
  add     (  square(x)  ,  square(y)  )
________     _________     _________
operator     operand 0     operand 1
```

All three subexpressions are evaluated in the current environment, which begins with the frame labeled sum_squares(). The operator subexpression add is a name found in the global frame, bound to the built-in function for addition. The two operand subexpressions must be evaluated in turn, before addition is applied. Both operands are evaluated in the current environment beginning with the frame labeled sum_squares.

In operand 0, square names a user-defined function in the global frame, while x names the number 5 in the local frame. Python applies square to 5 by introducing yet another local frame that binds x to 5.

![pt_10](/sicp-python/pt_10.png)

Using this environment, the expression `mul(x, x)` evaluates to 25.

Our evaluation procedure now turns to operand 1, for which y names the number 12. Python evaluates the body of square again, this time introducing yet another local frame that binds x to 12. Hence, operand 1 evaluates to 144.

![pt_11](/sicp-python/pt_11.png)


Finally, applying addition to the arguments 25 and 144 yields a final return value for `sum_squares`: 169.

![pt_12](/sicp-python/pt_12.png)

This example illustrates many of the fundamental ideas we have developed so far. Names are bound to values, which are distributed across many independent local frames, along with a single global frame that contains shared names. A new local frame is introduced every time a function is called, even if the same function is called twice.

All of this machinery exists to ensure that names resolve to the correct values at the correct times during program execution. This example illustrates why our model requires the complexity that we have introduced. All three local frames contain a binding for the name x, but that name is bound to different values in different frames. Local frames keep these names separate.

## 1.3.4 å±€éƒ¨åç§°

One detail of a function's implementation that should not affect the function's behavior is the implementer's choice of names for the function's formal parameters. Thus, the following functions should provide the same behavior:

```py
>>> def square(x):
        return mul(x, x)
>>> def square(y):
        return mul(y, y)
```


This principle -- that the meaning of a function should be independent of the parameter names chosen by its author -- has important consequences for programming languages. The simplest consequence is that the parameter names of a function must remain local to the body of the function.

If the parameters were not local to the bodies of their respective functions, then the parameterÂ xÂ inÂ squareÂ could be confused with the parameterÂ xÂ inÂ sum_squares. Critically, this is not the case: the binding forÂ xÂ in different local frames are unrelated. The model of computation is carefully designed to ensure this independence.

We say that theÂ _scope_Â of a local name is limited to the body of the user-defined function that defines it. When a name is no longer accessible, it is out of scope. This scoping behavior isn't a new fact about our model; it is a consequence of the way environments work.


## 1.3.5 é€‰æ‹©åç§°

The interchangeability of names does not imply that formal parameter names do not matter at all. On the contrary, well-chosen function and parameter names are essential for the human interpretability of function definitions!

The following guidelines are adapted from theÂ [style guide for Python code](http://www.python.org/dev/peps/pep-0008), which serves as a guide for all (non-rebellious) Python programmers. A shared set of conventions smooths communication among members of a developer community. As a side effect of following these conventions, you will find that your code becomes more internally consistent.

1.  Function names are lowercase, with words separated by underscores. Descriptive names are encouraged.
2.  Function names typically evoke operations applied to arguments by the interpreter (e.g.,Â print,Â add,Â square) or the name of the quantity that results (e.g.,Â max,Â abs,Â sum).
3.  Parameter names are lowercase, with words separated by underscores. Single-word names are preferred.
4.  Parameter names should evoke the role of the parameter in the function, not just the kind of argument that is allowed.
5.  Single letter parameter names are acceptable when their role is obvious, but avoid "l" (lowercase ell), "O" (capital oh), or "I" (capital i) to avoid confusion with numerals.

There are many exceptions to these guidelines, even in the Python standard library. Like the vocabulary of the English language, Python has inherited words from a variety of contributors, and the result is not always consistent.

## 1.3.6 ä½œä¸ºæŠ½è±¡çš„å‡½æ•°

Though it is very simple,Â sum_squaresÂ exemplifies the most powerful property of user-defined functions. The functionÂ sum_squaresÂ is defined in terms of the functionÂ square, but relies only on the relationship thatÂ squareÂ defines between its input arguments and its output values.

We can writeÂ sum_squaresÂ without concerning ourselves withÂ _how_Â to square a number. The details of how the square is computed can be suppressed, to be considered at a later time. Indeed, as far asÂ sum_squaresÂ is concerned,Â squareÂ is not a particular function body, but rather an abstraction of a function, a so-called functional abstraction. At this level of abstraction, any function that computes the square is equally good.

Thus, considering only the values they return, the following two functions for squaring a number should be indistinguishable. Each takes a numerical argument and produces the square of that number as the value.

```py
>>> def square(x):
Â Â Â      return mul(x, x)
>>> def square(x):
Â Â Â      return mul(x, x-1) + x
```

In other words, a function definition should be able to suppress details. The users of the function may not have written the function themselves, but may have obtained it from another programmer as a "black box". A programmer should not need to know how the function is implemented in order to use it. The Python Library has this property. Many developers use the functions defined there, but few ever inspect their implementation.

**Aspects of a functional abstraction.**Â To master the use of a functional abstraction, it is often useful to consider its three core attributes. TheÂ _domain_Â of a function is the set of arguments it can take. TheÂ _range_Â of a function is the set of values it can return. TheÂ _intent_Â of a function is the relationship it computes between inputs and output (as well as any side effects it might generate). Understanding functional abstractions via their domain, range, and intent is critical to using them correctly in a complex program.

For example, anyÂ squareÂ function that we use to implementÂ sum_squaresÂ should have these attributes:

-   TheÂ _domain_Â is any single real number.
-   TheÂ _range_Â is any non-negative real number.
-   TheÂ _intent_Â is that the output is the square of the input.

These attributes do not specify how the intent is carried out; that detail is abstracted away.

## 1.3.7 æ“ä½œç¬¦

Mathematical operators (such asÂ +Â andÂ -) provided our first example of a method of combination, but we have yet to define an evaluation procedure for expressions that contain these operators.

Python expressions with infix operators each have their own evaluation procedures, but you can often think of them as short-hand for call expressions. When you see

```py
>>> 2 + 3
5
```

simply consider it to be short-hand for

```py
>>> add(2, 3)
5
```

Infix notation can be nested, just like call expressions. Python applies the normal mathematical rules of operator precedence, which dictate how to interpret a compound expression with multiple operators.

```py
>>> 2 + 3 * 4 + 5
19
```

evaluates to the same result as

```py
>>> add(add(2, mul(3, 4)), 5)
19
```

The nesting in the call expression is more explicit than the operator version, but also harder to read. Python also allows subexpression grouping with parentheses, to override the normal precedence rules or make the nested structure of an expression more explicit.

```py
>>> (2 + 3) * (4 + 5)
45
```

evaluates to the same result as

```py
>>> mul(add(2, 3), add(4, 5))
45
```

When it comes to division, Python provides two infix operators:Â /Â andÂ //. The former is normal division, so that it results in aÂ _floating point_, or decimal value, even if the divisor evenly divides the dividend:

```py
>>> 5 / 4
1.25
>>> 8 / 4
2.0
```

TheÂ //Â operator, on the other hand, rounds the result down to an integer:

```py
>>> 5 // 4
1
>>> -5 // 4
-2
```

These two operators are shorthand for theÂ truedivÂ andÂ floordivÂ functions.

```py
>>> from operator import truediv, floordiv
>>> truediv(5, 4)
1.25
>>> floordiv(5, 4)
1
```

You should feel free to use infix operators and parentheses in your programs. Idiomatic Python prefers operators over call expressions for simple mathematical operations.